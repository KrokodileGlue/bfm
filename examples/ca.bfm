print "         One Dimensional Cellular Automata in brainfuck\n"
print "                  by retrosegfault.tumblr.com\n"

define WIDTH 66;

define RULE_90  0;     define RULE_30  1;
define RULE_150 2;     define RULE_73  3;

array digits 3;
array field (WIDTH * 2);

field[WIDTH + WIDTH / 2] = 1; // initial condition

var generation     var i
var flag           var null /* used to throw away values
                             * we don't want to keep */

var algo
print "\t0: rule 90\n\t1: rule 30\n\t2: rule 150\n\t3: rule 73\n"
print "select an algorithm: "
input algo        algo - '0';
input null /* eat the return character */

print "generations: "
decimal generation

macro get_neighbors (field, i, left, center, right)
	var left_idx       var center_idx       var right_idx

	left_idx   = i
	left_idx   - 1;
	center_idx = i
	right_idx  = i
	right_idx  + 1;

	var is_i_width      is_i_width = i
	var is_i_zero       is_i_zero  = i
	is_i_zero  == 0;
	is_i_width == WIDTH - 1;
	
	if is_i_width
		right_idx = 0;
	end
	if is_i_zero
		left_idx  = WIDTH - 1;
	end

	left   = field[left_idx]
	center = field[center_idx]
	right  = field[right_idx]
end

macro rule90 (left, center, right, not_left, not_center, not_right, result)
	if left
		if center
			if not_right
				result = 1;
			end
		end
		if not_center
			if not_right
				result = 1;
			end
		end
	end
	if not_left
		if center
			if right
				result = 1;
			end
		end
		if not_center
			if right
				result = 1;
			end
		end
	end
end

macro rule30 (left, center, right, not_left, not_center, not_right, result)
	if left
		if not_center
			if not_right
				result = 1;
			end
		end
	end
	
	if center
		if not_left
			result = 1;
		end
	end
	
	if right
		if not_center
			if not_left
				result = 1;
			end
		end
	end
end

macro rule150 (left, center, right, not_left, not_center, not_right, result)
	if left
		if center
			if right
				result = 1;
			end
		end
		if not_center
			if not_right
				result = 1;
			end
		end
	end
	
	if center
		if not_left
			if not_right
				result = 1;
			end
		end
	end
	
	if right
		if not_center
			if not_left
				result = 1;
			end
		end
	end
end

macro rule73 (left, center, right, not_left, not_center, not_right, result)
	if not_left
		if not_center
			if not_right
				result = 1;
			end
		end

		if center
			if right
				result = 1;
			end
		end
	end

	if left
		if center
			if not_right
				result = 1;
			end
		end
	end
end

/* will find the outcome for a given RULE_ from an idx
 * in a given field and write it to result. */
macro update_cell (field, i, algo, result)
	var left           var center           var right
	var not_left       var not_center       var not_right

	get_neighbors (field, i, left, center, right)

	not_left   = left      not not_left
	not_center = center    not not_center
	not_right  = right     not not_right

	var temp
	temp = algo     temp == RULE_90;
	if temp
		rule90 (left,     center,     right,
			not_left, not_center, not_right,
			result)
	end

	temp = algo     temp == RULE_30;
	if temp
		rule30 (left,     center,     right,
			not_left, not_center, not_right,
			result)
	end

	temp = algo     temp == RULE_150;
	if temp
		rule150 (left,     center,     right,
			 not_left, not_center, not_right,
			 result)
	end

	temp = algo     temp == RULE_73;
	if temp
		rule73 (left,     center,     right,
			not_left, not_center, not_right,
			result)
	end
end

/* main loop */
while generation
	generation - 1;
	
	/* copy the buffer into the main field */
	i = WIDTH;
	while i
		i - 1;
		
		var idx    idx = i
		idx + WIDTH;
		field[i] = field[idx]
	end

	/* print the field */
	flag = 1;
	i = 0;
	while flag
		var temp
		temp = field[i]
		
		if temp
			print "#"
		end
		not temp
		if temp
			print " "
		end
		
		i + 1;
		flag = i    flag == WIDTH;
		not flag
	end
	print "\n"
	
	/* do the logic */
	i = WIDTH;
	while i
		var result          result = 0;
		i - 1;

		update_cell (field, i, algo, result)

		var idx    idx = i
		idx + WIDTH;
		
		field[idx] = result
	end
end